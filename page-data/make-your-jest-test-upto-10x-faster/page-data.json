{"componentChunkName":"component---src-templates-blog-post-js","path":"/make-your-jest-test-upto-10x-faster/","result":{"data":{"site":{"siteMetadata":{"title":"1Percent Blog  Kiran Anto"}},"markdownRemark":{"id":"4963870d-99c6-586d-a11a-77c06750b3b3","excerpt":"Imagine having to wait for 30 mins to finish the unit tests for a medium scale react project. A developer who wants to merge his code will have to now wait…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f78b80e3e32a5fb2fdc815a6daedc61e/d48f1/jest.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.02702702702703%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA3klEQVR42pXSS2vCQBQFYP9r1zVmopLMI2qdjFofIc4jREgriRrMQmx1EZVuLfirxI2bNjLCWd6PA4dbURYpizCRAFiYqOyg8gB/YDZ36ByzsO4+gUPLDar2mvoHONp6U9VsKYB1sbRI3g+KWXLJvnZ+JC2s3QyIqrsn+Vl4YvNi7xmPnDep2wyIarRyNMiNdgK9qNEWNfjMYIBkQx53BjNEUzpOuqOb/zPbP1jUYPbOz7vD7/54/i4uxc9WxtNXO9TCJkrpeNUPUjpZ9vwFm8SESf21uQG54dwjS/7kCvbtOX7LwEr3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Jest image\"\n        title=\"\"\n        src=\"/static/f78b80e3e32a5fb2fdc815a6daedc61e/fcda8/jest.png\"\n        srcset=\"/static/f78b80e3e32a5fb2fdc815a6daedc61e/12f09/jest.png 148w,\n/static/f78b80e3e32a5fb2fdc815a6daedc61e/e4a3f/jest.png 295w,\n/static/f78b80e3e32a5fb2fdc815a6daedc61e/fcda8/jest.png 590w,\n/static/f78b80e3e32a5fb2fdc815a6daedc61e/d48f1/jest.png 796w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Imagine having to wait for 30 mins to finish the unit tests for a medium scale react project. A developer who wants to merge his code will have to now wait additional 30 mins for the build checks, which is entirely frustrating. To focus on the velocity, this is when we decided to take some actions to improve this.</p>\n<p>Like what we all do, we started searching for different methods to improve the jest performance on google. This article lists down all the observations we had and the results. It may or may not work for your configuration, But I recommend going through this article and trying each method to see if it makes any difference.</p>\n<p>A golden rule of all optimizations is to measure. Yes, measure what is there currently. This includes all measurements that we need to keep track of and is listed here.</p>\n<ul>\n<li>Time to run the entire suite.</li>\n<li>Top 10 slowest suites with their times.</li>\n<li>Overall Memory consumed.</li>\n</ul>\n<h2 id=\"-1-making-network-calls-inside-the-tests\" style=\"position:relative;\"><a href=\"#-1-making-network-calls-inside-the-tests\" aria-label=\" 1 making network calls inside the tests permalink\" class=\"header-links before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a># 1 Making network calls inside the Tests</h2>\n<p>So when I started looking for what could be the reason for sluggish tests, one observation I got from the team was that it was flaky, and it might be making API calls inside the tests. This spiked my curiosity, and it was true. The test cases were making API calls and were waiting for their response which was one reason for slow tests.</p>\n<p>The best unit tests are tests that give the same result every single time you run the test. If they rely on a network, then that is simply impossible to achieve.</p>\n<p>The next step was to look for how to avoid this, and this is when we came across jest-offline. We started implementing this, but the next issue was that many test cases were making API calls, so we had to identify all of those and mock the calls manually, which took some time but was worth the effort.</p>\n<p><code class=\"language-text\">jest-offline</code> now enforces this rule so that if we don’t mock any calls, it directly fails the test.</p>\n<h2 id=\"2-there-could-be-more-than-just-network-calls\" style=\"position:relative;\"><a href=\"#2-there-could-be-more-than-just-network-calls\" aria-label=\"2 there could be more than just network calls permalink\" class=\"header-links before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>#2 There could be more than just network calls.</h2>\n<p>Upon finding that network calls could be one issue, the next thing was that we were searching for similar problems. Luckily, we encountered one more issue, which improved our test run times.</p>\n<p>Unit tests should be run independently and precise, but for us we were wrapping the test cases with Redux Provider, which was configured with persistReducer from <code class=\"language-text\">redux-persist</code>. The primary purpose of redux persist was to persist data across different tabs &#x26; sessions. Still, for UT, this is exactly the opposite, so removing this removed one IO operation from all the tests, which saved a lot of time.</p>\n<p><strong>Things to look out for</strong></p>\n<ul>\n<li>Cleanup Unnecessary IO Operations, like LocalStorage etc.</li>\n<li>unMocked timers in the test case.</li>\n<li>Unnecessary wrappers for components\n<ul>\n<li>Sentry wrapper —> Not required for UT</li>\n<li>Analytics wrapper —> Not required for UT.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-using-maxworkers50-to-get-the-optimal-performance\" style=\"position:relative;\"><a href=\"#3-using-maxworkers50-to-get-the-optimal-performance\" aria-label=\"3 using maxworkers50 to get the optimal performance permalink\" class=\"header-links before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>#3 Using MaxWorkers=50% to get the optimal performance.</h2>\n<p>Inspired by the article mentioned below, you can read more there.</p>\n<p><a href=\"https://dev.to/vantanev/make-your-jest-tests-up-to-20-faster-by-changing-a-single-setting-i36\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://dev.to/vantanev/make-your-jest-tests-up-to-20-faster-by-changing-a-single-setting-i36</a></p>\n<h2 id=\"4-switch-to-yarn--node-v16--jest-28\" style=\"position:relative;\"><a href=\"#4-switch-to-yarn--node-v16--jest-28\" aria-label=\"4 switch to yarn  node v16  jest 28 permalink\" class=\"header-links before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>#4 Switch to yarn + Node V16 + Jest 28</h2>\n<p>Jest had a lot of performance improvements. Hence we upgraded to 28. That goes the same with NodeJS as well. This change sped up our performance significantly.</p>\n<h2 id=\"4-fix-slowest-test-cases\" style=\"position:relative;\"><a href=\"#4-fix-slowest-test-cases\" aria-label=\"4 fix slowest test cases permalink\" class=\"header-links before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>#4 Fix slowest test cases</h2>\n<p>The first step of every optimization is to identify what is wrong, so identifying the slowest tests is also equally important. Maybe the slowest ten tests might be taking up more than 80% of the execution time. Who knows!</p>\n<p>use <code class=\"language-text\">jest-slow-test-reporter</code> to identify the slowest tests, and then start working on improving their performance of that. Make sure most of your tests are around 100ms or below. The slowest ones could max 300ms. Anything more than that is a red flag.</p>\n<h2 id=\"5-switch-to-swcjest-for-incredible-performance-boost\" style=\"position:relative;\"><a href=\"#5-switch-to-swcjest-for-incredible-performance-boost\" aria-label=\"5 switch to swcjest for incredible performance boost permalink\" class=\"header-links before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>#5 Switch to swc/jest for incredible performance boost.</h2>\n<p>With the advent of <code class=\"language-text\">esbuild</code>, the front-end world has become more demanding of speed in the development environment. <a href=\"https://github.com/swc-project/swc\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">swc</a> is an ultra-fast compiler written in rust. Why not use the same for Unit testing as well?</p>\n<p>Switch to <code class=\"language-text\">@swc/jest</code>, and you can see an immediate improvement in performance. For more info, you can refer to <a href=\"https://miyauchi.dev/posts/speeding-up-jest/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://miyauchi.dev/posts/speeding-up-jest/</a></p>\n<h2 id=\"6-memory-leaks\" style=\"position:relative;\"><a href=\"#6-memory-leaks\" aria-label=\"6 memory leaks permalink\" class=\"header-links before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>#6 Memory Leaks</h2>\n<p>Another culprint for slow and flaky tests is memory leaks, this is often ignored, so make an act to identify the tests causing memory leaks.</p>\n<p>For more info on identifying the memory leaks for your tests you can refer to: <a href=\"https://chanind.github.io/javascript/2019/10/12/jest-tests-memory-leak.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://chanind.github.io/javascript/2019/10/12/jest-tests-memory-leak.html</a></p>\n<h2 id=\"6-react-testing-library\" style=\"position:relative;\"><a href=\"#6-react-testing-library\" aria-label=\"6 react testing library permalink\" class=\"header-links before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>#6 React testing library</h2>\n<p>Another place to look for performance hogs, is how you write the test cases. Usage of incorrect selectors is one of the main reasons for slow tests. Few of the issues could be.</p>\n<ul>\n<li>Use of <code class=\"language-text\">.type</code> everywhere. Use it only where it is required, otherwise fall back to <code class=\"language-text\">.paste</code> as it’s much faster.</li>\n<li>You can refer to other common pitfalls from <a href=\"https://kentcdodds.com/blog/common-mistakes-with-react-testing-library\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://kentcdodds.com/blog/common-mistakes-with-react-testing-library</a></li>\n</ul>\n<p>Making sure you use the correct selectors and functionality improves the quality and performance of your unit tests.</p>\n<h2 id=\"7-additional\" style=\"position:relative;\"><a href=\"#7-additional\" aria-label=\"7 additional permalink\" class=\"header-links before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>#7 Additional</h2>\n<p>Few of the additional tips that could be used to improve performance are listed below.</p>\n<p><strong>findRelatedTests</strong></p>\n<p>This instantly reduces the time taken to run tests because usage of this flag will make sure that you only run the tests that are related to the code changes that you’ve made. So instead of running 1000+ tests, you may now only run 20 test cases for the 20 files that you changed.</p>\n<p>We could also use <code class=\"language-text\">--changedSince</code>, which runs tests related to the changes since the provided branch or commit hash.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">jest <span class=\"token parameter variable\">--changedSince</span> <span class=\"token operator\">&lt;</span>commit-id<span class=\"token operator\">></span></code></pre></div>\n<p><strong>JSDOM change</strong></p>\n<p>Changing the test environment from jsdom to something like LinkeDOM will improve the performance by at least 2X. But this is something that I wouldn’t recommend as I have not used it in a professional capacity yet. I would suggest you give it a try and see how it works with your configuration.</p>\n<h1 id=\"impact\" style=\"position:relative;\"><a href=\"#impact\" aria-label=\"impact permalink\" class=\"header-links before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h1>\n<ul>\n<li>Developers will only have to wait a fraction of the time they used to wait before to see the build checks on the PR, which improves the developer productivity and time management.</li>\n<li>The load on the CI will now drastically reduce, hence more savings.</li>\n</ul>\n<p>Hope these steps help you reduce the time taken for running Unit tests drastically. Do leave a comment about the achievements if you were able to make drastic differences with these tips.</p>","timeToRead":4,"frontmatter":{"title":"🏎 Make your Jest Tests upto 10x Faster","date":"May 25, 2022","description":"Tips on how to make your jest tests drastically faster, hence improving the developer productivity."}}},"pageContext":{"slug":"/make-your-jest-test-upto-10x-faster/","previous":{"fields":{"slug":"/a11y-visual-impairments/"},"timeToRead":2,"frontmatter":{"title":"♿ A11y: How can we improve the web experience for people with visual impairments?"}},"next":null}},"staticQueryHashes":["2841359383","3182425314"],"slicesMap":{}}